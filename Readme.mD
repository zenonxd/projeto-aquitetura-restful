# <center>SPRING BOOT 3 - MICHELLI BRITO 

## PRINCIPAIS ANOTA√á√ïES SPRING

### Bom, primeiro valos lembrar sobre **Invers√£o de Controle**?

√â um padr√£o de projeto, algo abstrato onde definimos todas as depend√™ncia de um determinado objeto, sem termos a necessidade de criar ou gerenciar. N√≥s passamos esse papel para o Spring (seu core.)

O **core** do Sring, portanto, **ter√° toda a responsabilidade de gerenciar todas as depend√™ncias**.

### Ok, mas como o Spring far√° isso?

Ele utiliza de uma implementa√ß√£o (a forma concreta), a **Inje√ß√£o de Depend√™ncia**. Portanto, a **Inje√ß√£o de Depend√™ncia, nada mais √©, do que a implementa√ß√£o concreta, da Inje√ß√£o de Controle**. üòä

Dessa forma, o Spring gerenciar√° todos esses **Beans**. **Beans**, s√£o os objetos que vamos criando conforme vamos construindo nossas aplica√ß√µes. E assim, o Spring vai cuidar das instancias de todos esses objetos.




O Spring anottations possui diversos tipos de anota√ß√µes, tais como:


### Stereotype
Precisamos mostrar ao Spring quais Beans (objetos), ele ir√° gerenciar. Um controller, Service, Repository... tudo isso √© um Bean. Um objeto passa a ser Bean quando passamos as anota√ß√µes.

- @Component - Todas as classes s√£o Component. Essa √© uma anota√ß√£o mais gen√©rica;
- @Repository - Classe onde ter√° l√≥gicas de neg√≥cio do banco de dados (transa√ß√µes);
- @Service - Classe de servi√ßo, onde envolve regras e l√≥gicas de neg√≥cio;
- @Controller - Utilizada quando utilizamos uma aplica√ß√£o que envolve camadas MVC (model view controller);
- @RestController - Para API Rest. Se teremos somente endpoints, expondo a API na Web, utilizamos este.
<hr>

### Core (Se divide em dois)
Tudo que envolve a base do Spring, est√° contida no Core, que fica dentro do projeto SpringFrameWork. Possui v√°rias configura√ß√µes prontas e tamb√©m 
a possibilidade de customizar e criar configura√ß√µes necess√°rias para nossa aplica√ß√£o.

#### 1. Beans
Agora que o Spring sabe quais classes ser√£o Beans em virtude das anota√ß√µes acima utilizadas (Esteri√≥tipos), ele precisa saber **onde ele ir√° injetar essas instancias quando necess√°rias**.

Bom, n√≥s utilizamos o **Bean Service** dentro do nosso **Controller**, por exemplo. Pois assim podemos usar os m√©todos **findAll**, **findById**, etc.
Portanto, a classe **Controller** ter√° uma **depend√™ncia da classe Service**.

Precisamos **mostrar essa dep√™ncia pro Spring**, para que ela saiba onde injet√°-las quando necess√°rio. Assim sendo, criaremos os **Pontos de Inje√ß√£o (Depend√™ncia) de uma classe com a outra**.

```java
@Autowired
@Qualifier("parkingSpotServiceImpl")
private ParkingSpotService parkingSpotService;
```
- @AutoWired - Sempre que necess√°rio, o Spring injetar√° o Bean Service, dentro do Bean Controller.

**Inicialmente, o ParkingSpotService importado acima, √© uma interface contendo diversos m√©todos. Essa interface pode ter outras classes utilizando os seus m√©todos
(implementando ela). Ou seja, o Spring n√£o consegue identificar qual Bean ser√° injetado. Qual a solu√ß√£o? Usar a Anota√ß√£o abaixo: @Qualifier**

- @Qualifier - Dentro dela, passamos qual Classe (que est√° implementando a interface/service) ser√° utilizada.


- @Value - Algumas vezes precisamos definir algumas vari√°veis nas propriedades que usamos dentro do codigo. Mas ao inv√©s
de deixar isso fixo em um Controller, por exemplo, √© uma boa pr√°ticar declarar essas propriedades dentro do arquivo properties.
Logo, se precisarmos fazer alguma melhoria/altera√ß√£o (**at√© mesmo sem parar a aplica√ß√£o**), fica muito mais f√°cil. Exemplo:
```properties
app.name=Parking Control API
app.port=80
app.host=parkingcontrolapp
```

Para que isso seja exibido ao utilizarmos um m√©todo, criamos uma vari√°vel dentro da classe passando o @Value.
```java
@Value("${app.name}")
private String name;

@Value("${app.port}")
private String appPort;

@Value("${app.host}")
private String appHost;
```
Para exibir os valores, √© s√≥ dar um SOUT dentro do m√©todo. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L72)
<hr>

#### 2. Context

- @Configuration - Podemos configurar Datas de forma global, declarar Beans...
**Sempre que o Spring iniciar a aplica√ß√£o, ele ir√° olhar para essa classe e levar em considera√ß√£o as customiza√ß√µes e configura√ß√µes que definirmos nessa classe de Configura√ß√£o.**
<hr>

- @ComponentScan - Podemos definir/excluir determinados pacotes que ser√£o passados na anota√ß√£o. Mostraremos para o Spring quais s√£o os pacotes que ele ir√° fazer uma "varredura", 
buscando pelos Beans que ele ir√° gerenciar. **Serve s√≥ para algo customizado mesmo, pois o Spring em s√≠ j√° faz uma varredura autom√°tica ao ser iniciado.**
```java
@Configuration
@ComponentScan(basePackages = "com.api.parkingcontrol")
public class BeanConfig{}
```
<hr>

- @Bean - Ao inv√©s de declararmos pro spring usando as anota√ß√µes esteri√≥tipos, faremos de outra maneira.
    
    Criamos uma classe por exemplo, chamada MyBean.
    Dentro da BeanConfig, criaremos um m√©todo que ir√° retornar exatamente o Objeto que criamos.
```java
@Bean
public myBean myBean() {
    return new MyBean();
}
```   
Pro Spring saber detectar que esse MyBean ser√° um Bean gerenciado, precisamos passar @Bean.

Para podermos visualizar o que est√° dentro da Classe MyBean, faremos uma inje√ß√£o de depend√™ncia dentro da Classe ParkingSpotController, assim como fizemos com o @Value.

Usa o Autowired para fazer a importa√ß√£o, e pode chamar o metodo com myBean.method(). [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L73C1-L74C1)

**Ok, isso foi um Bean criado por n√≥s. Mas eventualmente usaremos Beans advindos de bibliotecas terceirizadas, como fazer nestes casos?**

Dentro do nosso pom, inserimos uma depend√™ncia modelmapper, utilizada para convers√µes. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/pom.xml#L38)

#### Declarando Bean de uma biblioteca externa

Declaremos o Bean Modelmapper dentro da classe que iremos utilizar, mostrando que mesmo que esse Bean n√£o tenha sido criado por n√≥s, o Spring ir√° tamb√©m gerenci√°-lo.

```java
(dentro da classe config)
@Bean
public ModelMapper modelMapper() {
    return new ModelPapper();
}
```
E dentro da controller, que √© onde iremos iniciar, faremos a inje√ß√£o. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/services/impl/ParkingSpotServiceImpl.java#L29)
<hr>

- @Lazy - Quando a gente n√£o define nada na classe criada (passa somente @Component), o Spring internamente usa a "cria√ß√£o ansiosa". J√° criando estes Beans, os deixando dispon√≠veis para uso.
    
    Mas podemos fazer um "start pregui√ßoso". **Ou seja, falar pro Spring criar esse Bean somente quando precisar**.
    
    Passamos a anota√ß√£o @Lazy e ser√° feito dessa maneira.

    E como acionar esse Bean em um momento espec√≠fico pro Spring criar?

Bom, mesmo de sempre. Faremos a inje√ß√£o de depend√™ncia no controller com @Autowired importanto o Bean e assim o Spring carregar√° o m√©todo com @Lazy.

**Caso esse LazyBean n√£o esteja importado dentro de algum m√©todo, n√£o ser√° inicializado pois o Spring n√£o encontrar√° nenhum ponto de inje√ß√£o de depend√™ncia.**
<hr>

- @Primary - Como √© possivel ver no reposit√≥rio desse projeto nos links acima. N√≥s temos uma interface chamada ParkingSpotService. Essa interface est√° sofrendo duas importa√ß√µes (ParkingSpotServiceImpl e ParkingSpotServiceImplV2).

Se voc√™ n√£o especificar qual ele ir√° considerar nos pontos de inje√ß√£o que vamos criando, ele entrar√° em conflito. Precisamos declarar qual ele ir√° utilizar. Tipo quando passamos o arquivo no @Qualifier.

Ent√£o esse @Qualifier n√£o ir√° existir. **Usaremos, portanto, o @Primary**. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/services/impl/ParkingSpotServiceImpl.java#L18)

<hr>


- @Scope
- @PropertySource
- @PropertySources
- @Profile
<hr>

### Web

- @RestController
- @RequestMapping
- @PostMapping
- @GetMapping
- @PutMapping
- @DeleteMapping
- @RequestBody
- @PathVariable
- @RequestParam
- @CrossOrigin
<hr>

### Boot

- @SpringBootApplication
- @EnableAutoConfiguration
- @ConfigurationProperties
<hr>






## IN√çCIO
<hr>

### Core Container

√â dentro dele onde est√° a implementa√ß√£o de invers√£o de controle, utilizando a inje√ß√£o de depend√™ncia para gerenciar todos esse Beans. Mas...

### O que √© invers√£o de controle?  

√â um padr√£o de projeto, onde um objeto declara suas depend√™ncia mas n√£o as cria. O objeto deixa essa tarefa para o framework (Spring). O Spring far√° esse trabalho no Container IoC (Core Container), utilizando a inje√ß√£o de depend√™ncia.

### O que √© Inje√ß√£o de Depend√™ncia?

√â algo mais concreto. √â a implementa√ß√£o da inje√ß√£o de controle quando necess√°ria, √© feita pelo Spring Framework.

### O que s√£o Beans?

Nada mais √© do que um objeto que √© instanciado/montando/gerenciado por um Core Container do Spring, atrav√©s da Invers√£o de Controle e Inje√ß√£o de Depend√™ncia.
Exemplos.: @Component, @Service, @Repository, @Controller.

## Spring Boot

√â como se fosse uma somat√≥ria do Spring FrameWork + Servidor embutido (Tomcat ou Netty) - XML <bean> Configuration ou @Configuration

Antigamente precisava criar v√°rios arquivos XML pra definir algumas coisas, onde hoje tudo j√° vem configurado, automatizado e simplificado.
<hr>

## Overview do projeto

**PRODUTS API REStful - Products.**

### Model e Mapeamento da Entidade Product.
1. Criaremos um package model e uma classe ProductModel;
2. Passamos @Entity para ela se tornar uma entidade;
3. @Table(name = "TB_PRODUCTS");
4. Implementamos Serializable, passando private static final long serialVersionUID = 1L.

#### Inser√ß√£o de atributos
Algumas coisas aqui estar√£o diferentes do curso do N√©lio, uma vez que este curso √© um pouco mais atualizado.
Por exemplo:
1. o passar o GenerationType do Id, usaremos AUTO;
2. O Id n√£o ser√° integer e sim UUID;
   - UUID √© indicado para projetos que usam banco de dados, evita conflitos de termos ID semelhantes.
3. O value agora ser√° BigDecimal.
```java
@Entity
@Table(name = "TB_PRODUCTS")
public class ProductModel implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID idProduct;
    private String name;
    private BigDecimal value;
}
```
E agora, geramos nosso construtor e getters and setters. üòä
Rodando o c√≥digo Spring, dentro do pgAdmin 4 (postgres), a tabela ter√° sido inserida.


### Cria√ß√£o do Repository com JPA Repository
Contaremos com diversos m√©todos prontos sem precisar implementar cada um deles.
Seja para salvar recursos, obter uma lista de recursos um determinado recurso pelo ID, enfim... fazer tudo com JPA com facilidade!

1. Criaremos um novo pacote **repositories** com uma interface chamada ProductRepository;
2. Como sabemos, extendemos JpaRepository<**Entidade**, **Identificador**>;
3. Passamos a anota√ß√£o, pois precisamos mostrar pro spring que tal classe ser√° um bean gerenciado por ele;
   - Neste, caso: @Repository.
```java
@Repository
public interface ProductRepository extends JpaRepository<ProductModel, UUID> {}
```

### Cria√ß√£o do Controller

1. Criaremos um **ponto de inje√ß√£o**, visto que que Controller √© dependente de Repository.
   - Para isso, utilizaremos o @Autowired, importando o ProductRepository.
2. Implementaremos agora os m√©todos CRUD.

<hr>

#### POST
O POST receber√° o recurso, ir√° fazer uma valida√ß√£o inicial e salvar na base de dados.
Antes disso, para recebermos esses valores via JSON, precisaremos mapear esses campos.

Para isso, usaremos uma feature: **records**. Eles nos permitem iniciar esses objetos para transfer√™ncia de dados, como os DTOS por exemplo.
Criaremos portanto, um DTO, ele:
1. Ir√° receber dados desse recurso "Product";
2. Far√° a valida√ß√£o inicial;
3. Se tudo estiver OK, ele far√° a convers√£o para o model e salva este recurso na base de dados.
<hr>

### Mapeamento DTO de entrada com records
1. Criamos o pacote dtos;
2. Criamos um Record DTO, denominado ProductRecordDto;
3. Passaremos os par√¢metros do Product, menos ID pois n√£o precisamos nos preocupar.
```java
public record ProductRecordDto(String name, BigDecimal Value){}
```
Destacando-se que o Record j√° possui m√©todos prontos, como: getters/constructores/equals&hashcode etc.

Records al√©m disso, s√£o **IMUT√ÅVEIS**, por isso, n√£o possuem m√©todos **SETTERS**.

**Para validarmos, dentro do par√¢metro passaremos algumas anota√ß√µes, como:**
```java
public record ProductRecordDto(@NotBlank String name, @NotNull BigDecimal value) {}
```

<hr>

### M√âTODO POST

```java
@PostMapping("/products")
public ResponseEntity<ProductModel> saveProduct(@RequestBody @Valid ProductRecordDto productRecordDto) {
    var productModel = new ProductModel();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.CREATED).body(productRepository.save(productModel));
}
```
ResponseEntity - Retorno do m√©todo, neste caso do ProductModel, que na linha abaixo, ser√° criado.

O m√©todo saveProduct vai receber como par√¢metro (corpo da solicita√ß√£o Http) um ProductRecordDto que cont√© um name e um value.

@RequestBody - Ajuda a deixar a aplica√ß√£o no padr√£o REST, pois, sem ela, se mapeamos algum endere√ßo, o Spring entende que √© algo que est√° dentro da nossa aplica√ß√£o, como um arquivo, por exemplo. O @ResponseBody vai entender que esse √© um endere√ßo de uma p√°gina da web, obedecendo ao princ√≠pio do REST de comunica√ß√£o via protocolo HTTP.

@Valid - Para que esses dados entrem de fato em vigor

Dentro da fun√ß√£o iniciamos um ProductModel. O Dto serve somente para receber o que est√° vindo na requisi√ß√£o do corpo em formato JSON.

Por isso na linha abaixo, usamos o BeanUtils.copyProperties para fazer a convers√£o de JSON para Model.

Nessa ultima linha, construimos o retorno. O retorno do tipo ResponseEntity ser√° em duas partes:
1. Status - Se tudo ocorreu bem, precisamos enviar para o cliente que o recurso foi criado. Usamos portanto: HttpStatus.CREATED
2. J√° no .body (corpo) dessa reposta, poderemos enviar o que foi salvo. (Nome e Valor) que o cliente colocou + o ID que ser√° gerado.
3. E pra fazer esse save? Como pode ser observado, estamos importando o productRepository. Usaremos seu m√©todo .save dentro do body, passando nosso var productModel.
<hr>

#### M√âTODO GET
```java
@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

Como s√£o **TODOS** os produtos, ele ir√° nos retornar uma **List** do tipo ProductModel.

Diferente do c√≥digo post, ele ir√° nos retornar o HttpStatus.OK. E o m√©todo de repository √© o .findAll() que nos retornar√° uma lista.
<hr>

### M√âTODO GET (COM ID)

```java
@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    else {
        return ResponseEntity.status(HttpStatus.OK).body(productO.get());
    }
}
```

O @PathVariable nos ajuda a pegar o {id} passado no @Get.

O m√©todo nos retornar√° um Optional.

Instanciaremos um objeto ProductModel do tipo Optional, e entraremos no repository, usando o findById passando a ID do m√©todo como par√¢metro.
Depois, √© aquele if padr√£o. Se estiver vazio, lan√ßa a mensagem de not found. Se n√£o estiver vazio, pega o product e passa no corpo da resposta.

<hr>

### M√âTODO PUT (UPDATE)

Put √© parecido com o getOneProduct porque tamb√©m precisamos passar o ID como par√¢metro do que vamos atualizar.

```java
@PutMapping("/products/{id}")
public ResponseEntity<Object> updateProduct(@PathVariable(value = "id") UUID id,
                                                @RequestBody @Valid ProductRecordDto productRecordDto) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    var productModel = productO.get();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.save(productModel));
}
```

Continua recebendo o PathVariable e UUID.

Mas dessa vez, receber√° tamb√©m o RequestBody e Valid, pois precisamos do name e value (ProductRecordDto) para realizarmos o update.

Criamos a vari√°vel productO que utilizando o repository, ir√° verificar se primeiro, o produto existe (buscando pela ID).

Se existir, fazemos o if para saber se est√° vazio.

Se n√£o estiver vazio, instanciaremos um ProductModel. Mas esse ProductModel, n√£o ser√° instanciado do zero igual na saveProduct. Iremos atribuir a essa vari√°vel o valor que ja recebeu da base dados "productO".

E da√≠ damos o retorno padr√£o dando o OK e salvando.
<hr>

### M√âTODO DEL (DELETE)



```java
@DeleteMapping("/products/{id}")
public ResponseEntity<Object> deleteProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productRepository.delete(productO.get());
    return ResponseEntity.status(HttpStatus.OK).body("Product deleted successfully.");
}
```
A partir de agora o c√≥digo ja est√° mais autoexplicativo.

Passamos os mesmos par√¢metros por√©m depois do if n√£o precisamos intanciar um ProductModel.

S√≥ passamos o delete do repository com o .get() para pegar toda a entidade.

Cabe destacar, que o repository possui outros deletes, tais como:
- deleteAll(), deleteById, etc...
<hr>

### Inserindo HATEOAS e Cria√ß√£o de hiperm√≠dias

Colocamos a depend√™ncia no maven.
```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

E extendemos na classe principal, tudo isso visando uma melhor **navegabilidade**.
```java
public class ProductModel extends RepresentationModel<ProductModel> implements Serializable {}
```

Agora, quando formos utilizar essa clase, internamente ele j√° vai ter alguns m√©todos (como add, por exemplo) para construimos alguns links para navegabilidade.
<hr>

### EXEMPLOS + ALTERA√á√ïES DOS M√âTODOS ACIMA.

#### NA CLASSE PRODUCTCONTROLLER <<<
Como √© poss√≠vel ver nos m√©todos acima, **fazemos no proprio retorno a busca ou save ou qualquer outro m√©todo do repository**, iremos mudar isso.

Import dos links e methodOn
```java
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;
```

Exemplo de altera√ß√£o:
```java
ANTES

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

```java
DEPOIS

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
   List<ProductModel> productsList = productRepository.findAll();
   if (!productsList.isEmpty()) {
      for (ProductModel product : productsList) {
         UUID id = product.getIdProduct();
         product.add(linkTo(methodOn(ProductController.class).getOneProduct(id)).withSelfRel());
      }
   }
   return ResponseEntity.status(HttpStatus.OK).body(productsList);
}
```

Em suma:
- Criamos uma Lista do tipo ProductModel e passamos o findAll dentro dela;
- Fazemos um if para saber se ela est√° vazia, se n√£o tiver:
  - Faremos um loop, criaremos uma vari√°vel ID e usaremos o product.add;
    - **O .add √© uma extens√£o do proprio RepresentationModel!**
  - Dentro do add, usaremos linkTo, methodOn e withSelfRel.

linkTo - Fala pra qual endpoint/m√©todo vamos redirecionar o cliente quando ele clicar neste link.

methodOn - Qual controller est√° esse m√©todo? E qual √© este m√©todo em s√≠ que vai receber esse redirecionamento?

Bom, se o cliente est√° numa lista de produtos, vamos redirecionar ele para um produto espec√≠fico, neste caso √© o **getOneProduct**.

1. Primeiro definimos qual Controller est√° esse m√©todo (ProductController.class);
2. E depois qual o nome desse m√©todo. Usaremos o m√©todo de baixo getOneProduct;
   3. Como esse m√©todo recebe um id, passamos o id que criamos em cima. (Id de cada um dos produtos iterado pelo for).

withSelfRel - Redireciona para cada um de seus produtos em s√≠.

![img_2.png](img_2.png)

```java
ALTERA√á√ÉO GET ONE PRODUCT

@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productO.get().add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel("Products List"));
    return ResponseEntity.status(HttpStatus.OK).body(productO.get());
}
```

√önica diferen√ßa √© que n√£o referenciamos por getOne, faremos o m√©todo .getAllProducts().

![img_1.png](img_1.png)