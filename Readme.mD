# SPRING BOOT 3 - MICHELLI BRITO

## ANOTA√á√ïES SPRING

- @Component - Classe mais gen√©rica;
- @Service - Classe de servi√ßo, onde envolve regras de neg√≥cio;
- @Repository - Classe onde ter√° transa√ß√µes com base de dados;
- @Controller - Ter√° endpoints.
- @RestController - Espec√≠fico para API Rest;
<hr>

## IN√çCIO
<hr>

### Core Container

√â dentro dele onde est√° a implementa√ß√£o de invers√£o de controle, utilizando a inje√ß√£o de depend√™ncia para gerenciar todos esse Beans. Mas...

### O que √© invers√£o de controle?  

√â um padr√£o de projeto, onde um objeto declara suas depend√™ncia mas n√£o as cria. O objeto deixa essa tarefa para o framework (Spring). O Spring far√° esse trabalho no Container IoC (Core Container), utilizando a inje√ß√£o de depend√™ncia.

### O que √© Inje√ß√£o de Depend√™ncia?

√â algo mais concreto. √â a implementa√ß√£o da inje√ß√£o de controle quando necess√°ria, √© feita pelo Spring Framework.

### O que s√£o Beans?

Nada mais √© do que um objeto que √© instanciado/montando/gerenciado por um Core Container do Spring, atrav√©s da Invers√£o de Controle e Inje√ß√£o de Depend√™ncia.
Exemplos.: @Component, @Service, @Repository, @Controller.

## Spring Boot

√â como se fosse uma somat√≥ria do Spring FrameWork + Servidor embutido (Tomcat ou Netty) - XML <bean> Configuration ou @Configuration

Antigamente precisava criar v√°rios arquivos XML pra definir algumas coisas, onde hoje tudo j√° vem configurado, automatizado e simplificado.
<hr>

## Overview do projeto

**PRODUTS API REStful - Products.**

### Model e Mapeamento da Entidade Product.
1. Criaremos um package model e uma classe ProductModel;
2. Passamos @Entity para ela se tornar uma entidade;
3. @Table(name = "TB_PRODUCTS");
4. Implementamos Serializable, passando private static final long serialVersionUID = 1L.

#### Inser√ß√£o de atributos
Algumas coisas aqui estar√£o diferentes do curso do N√©lio, uma vez que este curso √© um pouco mais atualizado.
Por exemplo:
1. o passar o GenerationType do Id, usaremos AUTO;
2. O Id n√£o ser√° integer e sim UUID;
   - UUID √© indicado para projetos que usam banco de dados, evita conflitos de termos ID semelhantes.
3. O value agora ser√° BigDecimal.
```java
@Entity
@Table(name = "TB_PRODUCTS")
public class ProductModel implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID idProduct;
    private String name;
    private BigDecimal value;
}
```
E agora, geramos nosso construtor e getters and setters. üòä
Rodando o c√≥digo Spring, dentro do pgAdmin 4 (postgres), a tabela ter√° sido inserida.


### Cria√ß√£o do Repository com JPA Repository
Contaremos com diversos m√©todos prontos sem precisar implementar cada um deles.
Seja para salvar recursos, obter uma lista de recursos um determinado recurso pelo ID, enfim... fazer tudo com JPA com facilidade!

1. Criaremos um novo pacote **repositories** com uma interface chamada ProductRepository;
2. Como sabemos, extendemos JpaRepository<**Entidade**, **Identificador**>;
3. Passamos a anota√ß√£o, pois precisamos mostrar pro spring que tal classe ser√° um bean gerenciado por ele;
   - Neste, caso: @Repository.
```java
@Repository
public interface ProductRepository extends JpaRepository<ProductModel, UUID> {}
```

### Cria√ß√£o do Controller

1. Criaremos um **ponto de inje√ß√£o**, visto que que Controller √© dependente de Repository.
   - Para isso, utilizaremos o @Autowired, importando o ProductRepository.
2. Implementaremos agora os m√©todos CRUD.

<hr>

#### POST
O POST receber√° o recurso, ir√° fazer uma valida√ß√£o inicial e salvar na base de dados.
Antes disso, para recebermos esses valores via JSON, precisaremos mapear esses campos.

Para isso, usaremos uma feature: **records**. Eles nos permitem iniciar esses objetos para transfer√™ncia de dados, como os DTOS por exemplo.
Criaremos portanto, um DTO, ele:
1. Ir√° receber dados desse recurso "Product";
2. Far√° a valida√ß√£o inicial;
3. Se tudo estiver OK, ele far√° a convers√£o para o model e salva este recurso na base de dados.
<hr>

### Mapeamento o DTO de entrada com records
1. Criamos o pacote dtos;
2. Criamos um Record DTO, denominado ProductRecordDto;
3. Passaremos os par√¢metros do Product, menos ID pois n√£o precisamos nos preocupar.
```java
public record ProductRecordDto(String name, BigDecimal Value){}
```
Destacando-se que o Record j√° possui m√©todos prontos, como: getters/constructores/equals&hashcode etc.

Records al√©m disso, s√£o **IMUT√ÅVEIS**, por isso, n√£o possuem m√©todos **SETTERS**.

**Para validarmos, dentro do par√¢metro passaremos algumas anota√ß√µes, como:**
```java
public record ProductRecordDto(@NotBlank String name, @NotNull BigDecimal value) {}
```

<hr>

### M√âTODO POST






#### GET

<hr>


