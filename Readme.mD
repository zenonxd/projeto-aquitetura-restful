# <center>SPRING BOOT 3 - MICHELLI BRITO 

<div align="center">

![img_3.png](img_3.png)
</div>
<hr>

## Videos de refer√™ncia para que essa documenta√ß√£o fosse feita üëá
- [Spring Boot Annotations | +30 anota√ß√µes na pr√°tica](https://www.youtube.com/watch?v=Pd5tr483No0&ab_channel=MichelliBrito)
- [Spring Boot 3 | Curso Completo 2023](https://www.youtube.com/watch?v=wlYvA2b1BWI&ab_channel=MichelliBrito)
- PDF Spring Boot Da API REST aos Microservices ‚Äì 4¬™ Edi√ß√£o, Michelli Brito.
- [Instagram Michelli](https://www.instagram.com/brito_michelli/)
- [Youtube Michelli](https://www.youtube.com/@MichelliBrito)
<hr>

## T√≥picos
- [Invers√£o de Controle](#bom-primeiro-vamos-lembrar-sobre-invers√£o-de-controle)
- [Inje√ß√£o de Depend√™ncia](#inje√ß√£o-de-depend√™ncia)
- [Core Container](#core-container)
- [Beans](#beans)
- [Anota√ß√µes Spring](#principais-anota√ß√µes-spring)
- [API REST e RESTful](#api-rest-e-restful)
- [Projeto Criando API REST com SpringBoot](#criando-api-rest-com-spring-boot)
  - [Model e Mapeamento Entidade Product](#model-e-mapeamento-da-entidade-product)
  - [Inser√ß√£o de Atributos](#inser√ß√£o-de-atributos)
  - [Cria√ß√£o Repository com JPA](#cria√ß√£o-do-repository-com-jpa-repository)
  - [Cria√ß√£o Controller](#cria√ß√£o-do-controller)
  - [Mapeamento DTO entrada com records](#mapeamento-dto-de-entrada-com-records)
  - [POST](#post)
  - [M√âTODO POST](#m√©todo-post)
  - [M√âTODO GET](#m√©todo-get)
  - [M√âTODO GET COM ID](#m√©todo-get-com-id)
  - [M√âTODO PUT (UPDATE)](#m√©todo-put-update)
  - [M√âTODO DELETE](#m√©todo-del-delete)
  - [Inserindo HATEOAS e Cria√ß√£o de hiperm√≠dias](#inserindo-hateoas-e-cria√ß√£o-de-hiperm√≠dias)
  - [Altera√ß√µes Finais dos M√©todos Acima](#exemplos--altera√ß√µes-dos-m√©todos-acima)
<hr>

### Bom, primeiro vamos lembrar sobre **Invers√£o de Controle**?

√â um padr√£o de projeto, algo abstrato onde definimos todas as depend√™ncias de um determinado objeto, sem termos a necessidade de criar ou gerenciar. N√≥s passamos esse papel para o Spring (seu core.)

O **core** do Sring, portanto, **ter√° toda a responsabilidade de gerir todas as depend√™ncias**.

Exemplo: Imagine que temos duas classes, A e B.
A classe A, possui uma depend√™ncia da classe B, visto que ela utiliza um m√©todo da mesma.
Portanto, a Classe A teria que criar sempre uma inst√¢ncia da classe B para que assim pudesse utilizar o seu m√©todo.

<div align="center">

![img_4.png](img_4.png)
</div>

Mas, quando utilizamos invers√£o de controle, a Classe A n√£o precisa se preocupar em criar inst√¢ncias da B. Podemos passara essa responsabilidade para o Spring, conforme dito acima.

**Ele realizar√° essa Invers√£o de Controle, atrav√©s da Inje√ß√£o de Depend√™ncia**.

### Inje√ß√£o de Depend√™ncia

√â a maneira como o Spring aplica a Invers√£o de Controle (defini√ß√£o de depend√™ncia) quando necess√°rio.

A Inje√ß√£o de Depend√™ncia define quais classes ser√£o instanciadas e em quais lugares ser√£o injetadas quando houver necessidade.

Portanto, a **Inje√ß√£o de Depend√™ncia, nada mais √©, do que a implementa√ß√£o concreta, da Inje√ß√£o de Controle**. üòä

#### <center> Ok, mas como o Spring definir√° isso?

Basta que a classe A crie um Ponto de Inje√ß√£o da classe B atrav√©s do construtor. E assim, quando houver necessidade o Spring usar√° a inst√¢ncia da classe B,
possibilitando que a classe A, possa utilizar o seu m√©todo b.metodoB(), conforme abaixo:

<div align="center">

![img_5.png](img_5.png)
</div>


Dessa forma, o Spring gerenciar√° todos esses **Beans**. **Beans**, s√£o os objetos que vamos criando conforme vamos construindo nossas aplica√ß√µes. E assim, o Spring vai cuidar das instancias de todos esses objetos.
<hr>

## Core Container

Quando o Spring utiliza Inje√ß√£o de Depend√™ncia para aplicar a Invers√£o de Controle, toda essa implementa√ß√£o est√° presente no Core Container (onde fica a base de configura√ß√£o do Spring Framework).

Ao executarmos a aplica√ß√£o o Core Container √© iniciado, as configura√ß√µes da aplica√ß√£o pr√©-definidas em classes ou arquivos XML s√£o lidas e as depend√™ncias necess√°rias s√£o definidas e criadas
atrav√©s da IoC. Elas s√£o destru√≠das quando n√£o forem mais utilizadas.

Essas depend√™ncias definidas s√£o denominadas **Beans**. Beans s√£o objetos que possuem seu ciclo de vida gerenciado pelo container da IoC/ID do Spring.

Esses passos definem o ciclo de vida de um Container, como pode ser visto abaixo.
<div align="center">

![img_6.png](img_6.png)
</div>
<hr>

## Beans

Como falamos acima, Beans s√£o objetos instanciados, montados e gerenciados por um container do Spring atrav√©s da Invers√£o de Controle e Inje√ß√£o de Depend√™ncias.

Assim como um container, um Bean tamb√©m tem o seu ciclo de vida. Ele √© iniciado e criado pelo container, as depend√™ncias desse Bean s√£o injetadas,
o metodo de inicializa√ß√£o √© chamada e ent√£o, o bean √© enviado para o cliente, **no caso a classe que possui essa depend√™ncia**. Ele ser√° utilizado e descartado.

Em suma, usando o exemplo acima, quando o container √© instanciado ele cria uma inst√¢ncia da classe B, chama o construtor da classe A para injetar esse bean e em seguida,
a classe A utiliza esse Bean atrav√©s de b.metodoB().

Ap√≥s isso, esse Bean √© descartado quando n√£o mais utilizado e tal ciclo pode ser visualizado abaixo.
<div align="center">

![img_7.png](img_7.png)
</div>

O ciclo de vida de um bean depende do seu escopo, que pode ser determinado no Spring atrav√©s da anota√ß√£o @Scope. Os tipos de escopos
do Spring utilizados para web s√£o:
- Singleton - O container ir√° criar uma √∫nica inst√¢ncia desse bean e ser√° utilizada para todas as solicita√ß√µes da inst√¢ncia;
- Prototype - O container ir√° criar v√°rias inst√¢ncias, uma para cada solicita√ß√£o;
- Request - Ter√° uma inst√¢ncia criada para cada requisi√ß√£o HTTP;
- Session - Ter√° a sua inst√£ncia preservada e utilizada para solicita√ß√µes enquanto durar a sess√£o.

<hr>

## Configurando Beans no Spring
√â preciso que o Spring conhe√ßa quais as classes da aplica√ß√£o ser√£o beans gerenciados por ele para que ent√£o seja aplicada a IoC/ID.
Para isso h√° duas maneiras de configurar e determinar esses beans, utilizando configura√ß√µes em arquivos XML ou por anota√ß√µes.
XML hoje n√£o s√£o muito utilizadas, por isso utilizaremos as anota√ß√µes.

Nas anota√ß√µes, utilizaremos esteri√≥tipos do Spring, definindo de forma objetiva (e espec√≠fica), qual o tipo de Bean de cada classe, a saber:

## Principais Anota√ß√µes Spring

<details>
<summary>VER MAIS</summary>

## <center> Stereotype
Precisamos mostrar ao Spring quais Beans (objetos), ele ir√° gerenciar. Um controller, Service, Repository... tudo isso √© um Bean. Um objeto passa a ser Bean assim que passamos as anota√ß√µes.

- @Component - Todas as classes s√£o Component. Essa √© uma anota√ß√£o mais gen√©rica;
```java
@Component
public class Product {

 private String name;
 private BigDecimal value;

 //... getters and setters
}
```
- @Repository - Classe onde ter√° l√≥gicas de neg√≥cio do banco de dados (transa√ß√µes);
```java
@Repository
public class ProductRepository {
 // database transaction methods
}
```
- @Service - Classe de servi√ßo, onde envolve regras e l√≥gicas de neg√≥cio;
```java
@Service
public class ProductService {
 // business rules
}
```
- @Controller - Utilizada quando utilizamos uma aplica√ß√£o que envolve camadas MVC (model view controller);
```java
@Controller
public class ProductController {
 // ... GET, POST, DELETE, UPDATE methods
}
```
- @RestController - Para API Rest. Se teremos somente endpoints, expondo a API na Web, utilizamos este.
<hr>

## <center> Core (Se divide em dois)
Tudo que envolve a base do Spring, est√° contida no Core, que fica dentro do projeto SpringFrameWork. Possui v√°rias configura√ß√µes prontas e tamb√©m
a possibilidade de customizar e criar configura√ß√µes necess√°rias para nossa aplica√ß√£o.

### <center> 1. Beans
Agora que o Spring sabe quais classes ser√£o Beans em virtude das anota√ß√µes acima utilizadas (Esteri√≥tipos), ele precisa saber **onde ele ir√° injetar essas instancias quando necess√°rias**.

Bom, n√≥s utilizamos o **Objeto Service** dentro do nosso **Controller**, por exemplo. Pois assim podemos usar os m√©todos **findAll**, **findById**, etc.
Portanto, a classe **Controller** ter√° uma **depend√™ncia da classe Service**.

Precisamos **mostrar essa dep√™ncia pro Spring**, para que ela saiba onde injet√°-las quando necess√°rio. Assim sendo, criaremos os **Pontos de Inje√ß√£o (Depend√™ncia) de uma classe com a outra**.

```java
@Autowired
@Qualifier("parkingSpotServiceImpl")
private ParkingSpotService parkingSpotService;
```
- @AutoWired - Sempre que necess√°rio, o Spring injetar√° o Bean Service, dentro do Bean Controller.

**Inicialmente, o ParkingSpotService importado acima, √© uma interface contendo diversos m√©todos. Essa interface pode ter outras classes utilizando os seus m√©todos
(implementando ela). Ou seja, o Spring n√£o consegue identificar qual Bean ser√° injetado. Qual a solu√ß√£o? Usar a Anota√ß√£o abaixo: @Qualifier**

- @Qualifier - Dentro dela, passamos qual Classe (que est√° implementando a interface/service) ser√° utilizada.


- @Value - Algumas vezes precisamos definir algumas vari√°veis nas propriedades que usamos dentro do codigo. Mas ao inv√©s
  de deixar isso fixo em um Controller, por exemplo, √© uma boa pr√°ticar declarar essas propriedades dentro do arquivo properties.
  Logo, se precisarmos fazer alguma melhoria/altera√ß√£o (**at√© mesmo sem parar a aplica√ß√£o**), fica muito mais f√°cil. Exemplo:
```properties
app.name=Parking Control API
app.port=80
app.host=parkingcontrolapp
```

Para que isso seja exibido ao utilizarmos um m√©todo, criamos uma vari√°vel dentro da classe passando o @Value.
```java
@Value("${app.name}")
private String name;

@Value("${app.port}")
private String appPort;

@Value("${app.host}")
private String appHost;
```
Para exibir os valores, √© s√≥ dar um SOUT dentro do m√©todo. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L72)
<hr>

### <center> 2. Context

- @Configuration - Podemos configurar Datas de forma global, declarar Beans...
  **Sempre que o Spring iniciar a aplica√ß√£o, ele ir√° olhar para essa classe e levar√° em considera√ß√£o as customiza√ß√µes e configura√ß√µes que definirmos nessa classe de Configura√ß√£o.**
<hr>

- @ComponentScan - Podemos definir/excluir determinados pacotes que ser√£o passados na anota√ß√£o. Mostraremos para o Spring quais s√£o os pacotes que ele ir√° fazer uma "varredura",
  buscando pelos Beans que ele ir√° gerenciar. **Serve s√≥ para algo customizado mesmo, pois o Spring em s√≠ j√° faz uma varredura autom√°tica ao ser iniciado.**
```java
@Configuration
@ComponentScan(basePackages = "com.api.parkingcontrol")
public class BeanConfig{}
```
<hr>

- @Bean - Ao inv√©s de declararmos pro spring usando as anota√ß√µes esteri√≥tipos, faremos de outra maneira.

  Criamos uma classe, por exemplo, chamada MyBean.

  Dentro da BeanConfig, criaremos um m√©todo que ir√° retornar exatamente o Objeto que criamos.
```java
@Bean
public myBean myBean() {
    return new MyBean();
}
```   
Pro Spring saber detectar que esse MyBean ser√° um Bean gerenciado, precisamos passar @Bean.

Para podermos visualizar o que est√° dentro da Classe MyBean, faremos uma inje√ß√£o de depend√™ncia dentro da Classe ParkingSpotController, assim como fizemos com o @Value.

Usa o Autowired para fazer a importa√ß√£o, e pode chamar o metodo com myBean.method(). [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L73C1-L74C1)

<div style="text-align: center;"> <b>Ok, isso foi um Bean criado por n√≥s. Mas eventualmente usaremos Beans advindos de bibliotecas terceirizadas, como fazer nestes casos?</b> </div>

Dentro do nosso pom, inserimos uma depend√™ncia modelmapper, utilizada para convers√µes. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/pom.xml#L38)

### Declarando Bean de uma biblioteca externa

Declaremos o Bean Modelmapper dentro da classe que iremos utilizar, mostrando que mesmo que esse Bean n√£o tenha sido criado por n√≥s, o Spring ir√° tamb√©m gerenci√°-lo.

```java
(dentro da classe config)
@Bean
public ModelMapper modelMapper() {
    return new ModelPapper();
}
```
E dentro da controller, que √© onde iremos iniciar, faremos a inje√ß√£o. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/services/impl/ParkingSpotServiceImpl.java#L29)
<hr>

- @Lazy - Quando a gente n√£o define nada na classe criada (passa somente @Component), o Spring internamente usa a "cria√ß√£o ansiosa". J√° criando estes Beans, os deixando dispon√≠veis para uso.

Mas podemos fazer um "start pregui√ßoso". **Ou seja, falar pro Spring criar esse Bean somente quando precisar**.

Passamos a anota√ß√£o @Lazy e ser√° feito dessa maneira.

E como acionar esse Bean em um momento espec√≠fico pro Spring criar?

Bom, mesmo de sempre. Faremos a inje√ß√£o de depend√™ncia no controller com @Autowired importanto o Bean e assim o Spring carregar√° o m√©todo com @Lazy. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L46)

**Caso esse LazyBean n√£o esteja importado dentro de algum m√©todo, n√£o ser√° inicializado pois o Spring n√£o encontrar√° nenhum ponto de inje√ß√£o de depend√™ncia.**
<hr>

- @Primary - Como √© possivel ver no reposit√≥rio desse projeto nos links acima. N√≥s temos uma interface chamada **ParkingSpotService**. Essa interface est√° sofrendo duas importa√ß√µes (ParkingSpotServiceImpl e ParkingSpotServiceImplV2).

Se voc√™ n√£o especificar qual dessas o Spring ir√° considerar nos pontos de inje√ß√£o que vamos criando, ele entrar√° em conflito. Precisamos declarar qual ele ir√° utilizar. Tipo quando passamos o arquivo no @Qualifier.

Ent√£o esse @Qualifier n√£o ir√° existir. **Usaremos, portanto, o @Primary**. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/services/impl/ParkingSpotServiceImpl.java#L18)

<hr>

- @Scope - Utilizaremos o Controller novamente e, nela, passaremos o @Scope.
Utilizaremos o par√¢metro singleton, conforme vimos na parte de [Beans](#beans).
Em suma, o @Scope define como o Spring ir√° lidar com as cria√ß√µes dos Beans (dependendo do par√¢metro).
<hr>

- @PropertySource - E se quisermos criar outro arquivo .properties com configura√ß√µes customizadas?
Cabe destacar que o Sring l√™ a application.properties por default.

Podemos criar no package Resources um "custom.properties, por exemplo, contendo o que desejarmos.
No controller, criaremos uma v√°rivel do tipo de conte√∫do que criamos no arquivo "properties". Se for uma String, criaremos uma vari√°vel tipo String usando Anottation @Value. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L61)

Mas isso n√£o √© o suficiente. O Spring precisa saber o arquivo pro Spring.
Passamos a anota√ß√£o @PropertSoruce("classpath:custom.properties") [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L35)

- @PropertySources - Se for multiplos arquivos de .properties, usa ele para declarar todos os caminhos desejados.
<hr>

- @Profile - Imagine que temos um m√©todo que retorne a mesma coisa (objeto, por exemplo), por√©m com m√©todos diferentes e os dois est√£o com anota√ß√£o @Bean.

Nessa situa√ß√£o, passaremos o @Profile dizendo qual ser√° qual. Por√©m essa forma n√£o √© a ideal, ao inciarmos a aplica√ß√£o teremos um conflito. O Spring n√£o consegue saber qual perfil est√° ativo.

#### Jeitos de realizar
1. Na nossa application.properties, colocaremos logo no come√ßo: ```spring.profiles.active=dev``` ou =prod (o que tiver no @Profile).


2. Ao inv√©s de usarmos a anota√ß√£o dentro no m√©todo dentro da BeanConfig, criaremos uma classe para cada Profile.
E assim sendo, declararemos o @Profile na classe em s√≠. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/configs/DevBeanConfig.java#L9)
Na .properties mant√©m o que a gente quer passar no profile.active. O que muda mesmo √© onde declaramos o @Profile.
<hr>

### Web
**Todas as Anottations web ficam no Controller** (EndPoints).

- @RestController - Usado para servi√ßo RESTful = @Controller + @ResponseBody.


- @RequestMapping - Definimos qual a URI que o cliente ir√° enviar para acessar todos os m√©todos desse EndPoint.
Primeiro passamos s√≥ inicio dela, depois nos outros metodos abaixo passaremos o resto. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L33)
```
Derivam do RequestMapping. Receberam uma fun√ß√£o POST, GET, PUT ou DEL do tipo HTTP.

@PostMapping
@GetMapping - 
@PutMapping
@DeleteMapping
```

- @RequestBody - Ele vai desserializar de JSON para Objeto Java. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L92)


- @PathVariable - No @GetMapping, por exemplo, n√≥s passamos um caminho ```"/{id}"```. O PathVariable consegue recuperar essa parte da URI.
Basta passarmos nele ```(value = "id")```. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L83)


- @RequestParam - Parecido com o PathVariable, dependendo do par√¢metro, podemos colocar depois do primeiro par√¢metro, um required = true/false. Para ser obrigat√≥rio ou n√£o. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L133)


- @CrossOrigin - √â onde habilitamos o cors. √â onde determinamos as origens/dom√≠nios que ir√£o acessar a nossa API. Se colocar "*" ser√° all.
maxAge = tempo m√°ximo de resposta. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L32)
Pode ser feito a n√≠vel de: classe, m√©todo e tamb√©m configura√ß√µes globais da aplica√ß√£o.
<hr>

### Boot

- @SpringBootApplication - A classe void main ir√° conter essa anota√ß√£o inicial. Serve para darmos o "start".
Al√©m disso essa anota√ß√£o √© uma combina√ß√£o de 03 outras anota√ß√µes:
  1. ComponentScan - Falamos pro Spring onde ser√° os pacotes que ele ir√° fazer a varredura e os Beans que ele ir√° gerenciar;
  2. @Configuration - Mostra que √© um Bean de configura√ß√£o do Spring;
  3. @EnableAutoConfiguration - Veja abaixo üëá


- @EnableAutoConfiguration - Utilizada para dizer ao Spring para ele utilizar de forma autom√°tica as suas configura√ß√µes. (Tomcat, MVC, Config de registro de beans, etc...).


- @ConfigurationProperties - Lembra do @Value que passamos no Controller? Tivemos que criar variav√©is para acessar esses valores que foram passados na .properties.

N√≥s podemos, portanto, passar esses dados do .properties para um DTO. **Ou seja, converteremos de propriedade para objeto java.**
1. Criamos uma classe para isso, chamada AppProperties [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/AppProperties.java#L8);
2. A anota√ß√£o j√° vem com um par√¢metro chamado "prefix = app". Isso seria um prefixo comum entre as propriedades do arquivo .properties;
   3. Criamos os m√©todos que iremos utilizar. Se dentro da .properties temos app.name, app.port, app.host, criaremos as vari√°veis;
      ```java
         private String name;
         private String port;
         private String host;
      
        //criar tamb√©m os getters e setters.
      ```
   E ent√£o, dentro da classe Controller, podemos fazer o SOUT usando essa ponto de inje√ß√£o. [Veja aqui](https://github.com/MichelliBrito/parking-control-api/blob/8df47619b3016659e88dedb591c2f90ba25b5f4e/src/main/java/com/api/parkingcontrol/controllers/ParkingSpotController.java#L74)
</details>


<hr>

## API REST e RESTful

√â uma aplica√ß√£o cliente/servidor que envia e recebe dados por protocolo HTTP. Utiliza XML e JSON como padr√£o de comunica√ß√£o e tamb√©m pode ser
implementada na linguagem desejada.

O objetivo de desenvolver uma API √© para permitir a interoperabilidade entre aplica√ß√µes. Ou seja, que os dados fluam entre diversos sistemas com o m√≠nimo de interven√ß√£o
humana poss√≠vel. A mesma API pode, portanto, ser utilizada em um disposito ‚Äúdesktop‚Äù e mobile simultaneamente.

Uma API s√≥ √© RESTful quando se usa na sua implementa√ß√£o o conceito arquiterual REST. Em suma, **REST √© algo abstrato** enquanto **RESTful √© algo mais concreto**, como a
implementa√ß√£o deste modelo em alguma API.

### <center> Arquitetura REST
Uma arquitetura REST √© em resumo um conjunto de boas pr√°ticas. Existem 6 constraints obrigat√≥rias para uma API ser considerada REST.
1. Ela deve ser cliente/servidor, separando responsabilidades;
2. Stateless - N√£o guardar estado no servidor;
3. A aplica√ß√£o deve ter a capacidade de realizar cache para reduzir traf√©go de dados entre cliente/servidor;
4. Deve ter uma interface uniforme, contendo recursos bem definidos, apresentar hiperm√≠dias e utilizar corretamente m√©todos HTTP e c√≥digos de retorno;
5. O sistema deve ser constru√≠do em camadas, tendo a possibilidade de escalar a aplica√ß√£o em multiplos seridores;
6. a aplica√ß√£o deve ter a capacidade de evoluir sem a quebra da mesma, ou seja, c√≥digo sob demanda.
<hr>


## Spring Boot

√â como se fosse uma somat√≥ria do Spring FrameWork + Servidor embutido (Tomcat ou Netty) - XML <bean> Configuration ou @Configuration

Antigamente precisava criar v√°rios arquivos XML pra definir algumas coisas, onde hoje tudo j√° vem configurado, automatizado e simplificado.
<hr>

## Criando API REST com Spring Boot
### Overview do projeto

**PRODUTS API REStful - Products.**

### Model e Mapeamento da Entidade Product.
1. Criaremos um package model e uma classe ProductModel;
2. Passamos @Entity para ela se tornar uma entidade;
3. @Table(name = "TB_PRODUCTS");
4. Implementamos Serializable, passando private static final long serialVersionUID = 1L.

### Inser√ß√£o de atributos
Algumas coisas aqui estar√£o diferentes do curso do N√©lio, uma vez que este curso √© um pouco mais atualizado.
Por exemplo:
1. o passar o GenerationType do Id, usaremos AUTO;
2. O Id n√£o ser√° integer e sim UUID;
   - UUID √© indicado para projetos que usam banco de dados, evita conflitos de termos ID semelhantes.
3. O value agora ser√° BigDecimal.
```java
@Entity
@Table(name = "TB_PRODUCTS")
public class ProductModel implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID idProduct;
    private String name;
    private BigDecimal value;
}
```
E agora, geramos nosso construtor e getters and setters. üòä
Rodando o c√≥digo Spring, dentro do pgAdmin 4 (postgres), a tabela ter√° sido inserida.


### Cria√ß√£o do Repository com JPA Repository
Contaremos com diversos m√©todos prontos sem precisar implementar cada um deles.
Seja para salvar recursos, obter uma lista de recursos um determinado recurso pelo ID, enfim... fazer tudo com JPA com facilidade!

1. Criaremos um novo pacote **repositories** com uma interface chamada ProductRepository;
2. Como sabemos, extendemos JpaRepository<**Entidade**, **Identificador**>;
3. Passamos a anota√ß√£o, pois precisamos mostrar pro spring que tal classe ser√° um bean gerenciado por ele;
   - Neste, caso: @Repository.
```java
@Repository
public interface ProductRepository extends JpaRepository<ProductModel, UUID> {}
```

### Cria√ß√£o do Controller

1. Criaremos um **ponto de inje√ß√£o**, visto que que Controller √© dependente de Repository.
   - Para isso, utilizaremos o @Autowired, importando o ProductRepository.
2. Implementaremos agora os m√©todos CRUD.

<hr>

### POST
O POST receber√° o recurso, ir√° fazer uma valida√ß√£o inicial e salvar na base de dados.
Antes disso, para recebermos esses valores via JSON, precisaremos mapear esses campos.

Para isso, usaremos uma feature: **records**. Eles nos permitem iniciar esses objetos para transfer√™ncia de dados, como os DTOS por exemplo.
Criaremos portanto, um DTO, ele:
1. Ir√° receber dados desse recurso "Product";
2. Far√° a valida√ß√£o inicial;
3. Se tudo estiver OK, ele far√° a convers√£o para o model e salva este recurso na base de dados.
<hr>

### Mapeamento DTO de entrada com records
1. Criamos o pacote dtos;
2. Criamos um Record DTO, denominado ProductRecordDto;
3. Passaremos os par√¢metros do Product, menos ID pois n√£o precisamos nos preocupar.
```java
public record ProductRecordDto(String name, BigDecimal Value){}
```
Destacando-se que o Record j√° possui m√©todos prontos, como: getters/constructores/equals&hashcode etc.

Records al√©m disso, s√£o **IMUT√ÅVEIS**, por isso, n√£o possuem m√©todos **SETTERS**.

**Para validarmos, dentro do par√¢metro passaremos algumas anota√ß√µes, como:**
```java
public record ProductRecordDto(@NotBlank String name, @NotNull BigDecimal value) {}
```

<hr>

### M√âTODO POST

```java
@PostMapping("/products")
public ResponseEntity<ProductModel> saveProduct(@RequestBody @Valid ProductRecordDto productRecordDto) {
    var productModel = new ProductModel();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.CREATED).body(productRepository.save(productModel));
}
```
ResponseEntity - Retorno do m√©todo, neste caso do ProductModel, que na linha abaixo, ser√° criado.

O m√©todo saveProduct vai receber como par√¢metro (corpo da solicita√ß√£o Http) um ProductRecordDto que cont√© um name e um value.

@RequestBody - Ajuda a deixar a aplica√ß√£o no padr√£o REST, pois, sem ela, se mapeamos algum endere√ßo, o Spring entende que √© algo que est√° dentro da nossa aplica√ß√£o, como um arquivo, por exemplo. O @ResponseBody vai entender que esse √© um endere√ßo de uma p√°gina da web, obedecendo ao princ√≠pio do REST de comunica√ß√£o via protocolo HTTP.

@Valid - Para que esses dados entrem de fato em vigor

Dentro da fun√ß√£o iniciamos um ProductModel. O Dto serve somente para receber o que est√° vindo na requisi√ß√£o do corpo em formato JSON.

Por isso na linha abaixo, usamos o BeanUtils.copyProperties para fazer a convers√£o de JSON para Model.

Nessa ultima linha, construimos o retorno. O retorno do tipo ResponseEntity ser√° em duas partes:
1. Status - Se tudo ocorreu bem, precisamos enviar para o cliente que o recurso foi criado. Usamos portanto: HttpStatus.CREATED
2. J√° no .body (corpo) dessa reposta, poderemos enviar o que foi salvo. (Nome e Valor) que o cliente colocou + o ID que ser√° gerado.
3. E pra fazer esse save? Como pode ser observado, estamos importando o productRepository. Usaremos seu m√©todo .save dentro do body, passando nosso var productModel.
<hr>

### M√âTODO GET
```java
@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

Como s√£o **TODOS** os produtos, ele ir√° nos retornar uma **List** do tipo ProductModel.

Diferente do c√≥digo post, ele ir√° nos retornar o HttpStatus.OK. E o m√©todo de repository √© o .findAll() que nos retornar√° uma lista.
<hr>

### M√âTODO GET (COM ID)

```java
@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    else {
        return ResponseEntity.status(HttpStatus.OK).body(productO.get());
    }
}
```

O @PathVariable nos ajuda a pegar o {id} passado no @Get.

O m√©todo nos retornar√° um Optional.

Instanciaremos um objeto ProductModel do tipo Optional, e entraremos no repository, usando o findById passando a ID do m√©todo como par√¢metro.
Depois, √© aquele if padr√£o. Se estiver vazio, lan√ßa a mensagem de not found. Se n√£o estiver vazio, pega o product e passa no corpo da resposta.

<hr>

### M√âTODO PUT (UPDATE)

Put √© parecido com o getOneProduct porque tamb√©m precisamos passar o ID como par√¢metro do que vamos atualizar.

```java
@PutMapping("/products/{id}")
public ResponseEntity<Object> updateProduct(@PathVariable(value = "id") UUID id,
                                                @RequestBody @Valid ProductRecordDto productRecordDto) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    var productModel = productO.get();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.save(productModel));
}
```

Continua recebendo o PathVariable e UUID.

Mas dessa vez, receber√° tamb√©m o RequestBody e Valid, pois precisamos do name e value (ProductRecordDto) para realizarmos o update.

Criamos a vari√°vel productO que utilizando o repository, ir√° verificar se primeiro, o produto existe (buscando pela ID).

Se existir, fazemos o if para saber se est√° vazio.

Se n√£o estiver vazio, instanciaremos um ProductModel. Mas esse ProductModel, n√£o ser√° instanciado do zero igual na saveProduct. Iremos atribuir a essa vari√°vel o valor que ja recebeu da base dados "productO".

E da√≠ damos o retorno padr√£o dando o OK e salvando.
<hr>

### M√âTODO DEL (DELETE)

```java
@DeleteMapping("/products/{id}")
public ResponseEntity<Object> deleteProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productRepository.delete(productO.get());
    return ResponseEntity.status(HttpStatus.OK).body("Product deleted successfully.");
}
```
A partir de agora o c√≥digo ja est√° mais autoexplicativo.

Passamos os mesmos par√¢metros por√©m depois do if n√£o precisamos intanciar um ProductModel.

S√≥ passamos o delete do repository com o .get() para pegar toda a entidade.

Cabe destacar, que o repository possui outros deletes, tais como:
- deleteAll(), deleteById, etc...
<hr>

### Inserindo HATEOAS e Cria√ß√£o de hiperm√≠dias

Colocamos a depend√™ncia no maven.
```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

E extendemos na classe principal, tudo isso visando uma melhor **navegabilidade**.
```java
public class ProductModel extends RepresentationModel<ProductModel> implements Serializable {}
```

Agora, quando formos utilizar essa clase, internamente ele j√° vai ter alguns m√©todos (como add, por exemplo) para construimos alguns links para navegabilidade.
<hr>

### EXEMPLOS + ALTERA√á√ïES DOS M√âTODOS ACIMA.

#### <center> NA CLASSE PRODUCTCONTROLLER <<<
Como √© poss√≠vel ver nos m√©todos acima, **fazemos no proprio retorno a busca ou save ou qualquer outro m√©todo do repository**, iremos mudar isso.

Import dos links e methodOn
```java
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;
```

Exemplo de altera√ß√£o:
```java
ANTES

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

```java
DEPOIS

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
   List<ProductModel> productsList = productRepository.findAll();
   if (!productsList.isEmpty()) {
      for (ProductModel product : productsList) {
         UUID id = product.getIdProduct();
         product.add(linkTo(methodOn(ProductController.class).getOneProduct(id)).withSelfRel());
      }
   }
   return ResponseEntity.status(HttpStatus.OK).body(productsList);
}
```

#### <center> RESUMO

- Criamos uma Lista do tipo ProductModel e passamos o findAll dentro dela;
- Fazemos um if para saber se ela est√° vazia, se n√£o tiver:
  - Faremos um loop, criaremos uma vari√°vel ID e usaremos o product.add;
    - **O .add √© uma extens√£o do proprio RepresentationModel!**
  - Dentro do add, usaremos linkTo, methodOn e withSelfRel.

#### linkTo - Fala pra qual endpoint/m√©todo vamos redirecionar o cliente quando ele clicar neste link.

#### methodOn - Qual controller est√° esse m√©todo? E qual √© este m√©todo em s√≠ que vai receber esse redirecionamento?

Bom, se o cliente est√° numa lista de produtos, vamos redirecionar ele para um produto espec√≠fico, neste caso √© o **getOneProduct**.

1. Primeiro definimos qual Controller est√° esse m√©todo (ProductController.class);
2. E depois qual o nome desse m√©todo. Usaremos o m√©todo de baixo getOneProduct;
   3. Como esse m√©todo recebe um id, passamos o id que criamos em cima. (Id de cada um dos produtos iterado pelo for).

withSelfRel - Redireciona para cada um de seus produtos em s√≠.

![img_2.png](img_2.png)

```java
ALTERA√á√ÉO GET ONE PRODUCT

@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productO.get().add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel("Products List"));
    return ResponseEntity.status(HttpStatus.OK).body(productO.get());
}
```

√önica diferen√ßa √© que n√£o referenciamos por getOne, faremos o m√©todo .getAllProducts().

![img_1.png](img_1.png)
<hr>

# RESUMO

Abordando aqui o necess√°rio e o que lembrar ao criar um projeto Spring seguindo os ensinamentos API RESTful.

## Base Te√≥rica
1. Lembrar sobre [Invers√£o de Controle](#bom-primeiro-vamos-lembrar-sobre-invers√£o-de-controle)
2. [Inje√ß√£o de Depend√™ncia](#inje√ß√£o-de-depend√™ncia)
3. [Ciclo de vida do Bean](#beans) (se ser√° Singleton, Prototype, Request ou Session)
<hr>

## Pr√°tica

1. Configura√ß√£o de Beans passando as anota√ß√µes. Todas est√£o [aqui](#principais-anota√ß√µes-spring)
2. Lembrar da [arquitetura rest](#center-arquitetura-rest) e suas 6 constraints obrigat√≥rias
<hr>

## O que lembrar ao ir criando Objetos?

Lembrar de dentro da pasta .spring (dentro de java), criar os packages:
### domain
Onde ficar√° as entidades.

**Entidades** receber√£o os atributos que veremos na UML do projeto ou no
que for solicitado.
O que √© interessante inserir:
1. @Entity(name="users");
2. @Table(name="users") - Se o arquivo chama User o nome da table √© sempre plural;
3. @Getter & @Setter;
4. @AllArgsConstructor e se quiser noArgs tamb√©m;
5. @EqualsAndHashCode(of="aqui o que queremos, id por exemplo").

Passar as anota√ß√µes nos atributos.

E notar se ter√° alguma rela√ß√£o de ManyToMany, OneToOne, etc...

Se tiver que implementar algum ENUM, √© s√≥ criar ele e passar com @Enumetered

#### ID
- Pode ser do tipo Long ou UUID;
- Passar @ID e o @GenerationValue (.IDENTIY ou .AUTO)

#### Outros Campos
Se quisermos que um campo espec√≠fico (como CPF ou Email seja unico), passaremos
@Column(unique=true)
<hr>

### controller
Intera√ß√£o do client com o nosso backend.
**Para chamarmos os m√©todos criados.**

Aqui receberemos as requisi√ß√µes do cliente e passaremos adiante ao Service somente as informa√ß√µes
relevantes para completar a requisi√ß√£o.

Essa camada √© o "primeiro contato" com as requisi√ß√µes. Enviaremos tamb√©m ao cliente a resposta
(positiva ou negativa).

- Realizar apenas opera√ß√µes relacionadas a Request e Response (HTTP);
- N√£o possuir "conhecimento" sobre regras de neg√≥cios, ou acesso ao DB;
- Formada quase que exclusivamente por Middlewares.

Precisamos passar o @RequestMapping com a url onde iremos realizar as opera√ß√µes.

[Veja os m√©todos Get, Post e Delete](https://github.com/zenonxd/spring-data-jpa-2024/blob/c95c6fce7a07d3c59fd97a300b0b661a08de2364/src/main/java/com/bookstore/jpa/controller/BookController.java#L16)
<hr>

### dtos
O Dto serve somente para receber o que est√° vindo na requisi√ß√£o do corpo em formato JSON.
Em suma, √© o que o cliente passar√° no postman, por exemplo.

O dto j√° possui m√©todos prontos getters/constructores/equals&hashcode etc.
Mas n√£o possui Set, pois records s√£o imut√°veis.

Se atentar ainda, as anota√ß√µes dentro do par√¢mtro, @NotBlank/@NotNull, etc.

[Para ver mais](#mapeamento-dto-de-entrada-com-records)
<hr>

### repositories
Para persistirmos (salvarmos/encontrarmos) usu√°rio ou algo espec√≠fico.

O repository conta com diversos m√©todos prontos para manipula√ß√£o de tabelas, para n√£o precisarmos ficar implementando.

Ele ter√° contato direto com o banco de dados.

Criaremos uma interface com o nome do item + repository: ProductRepository e extenderemos
com JpaRepository<Entidade, Identificador>.

Passar anota√ß√£o @Repository e s√≥.

[Exemplo de m√©todos pronto.](https://github.com/zenonxd/spring-data-jpa-2024/blob/c95c6fce7a07d3c59fd97a300b0b661a08de2364/src/main/java/com/bookstore/jpa/repositories/BookRepository.java#L11)
Da para passar at√© query SQL e procurar algo por titulo da entidade.
<hr>

### services
Regras de neg√≥cio!
**Aqui faremos valida√ß√£o e verifica√ß√£o de m√©todos que iniciamos no repository.**

**Ter√° acesso ao repository ou a outras classes do tipo Service** com autowired.

√â a camada intermedi√°ria da arquitetura MSC, respons√°vel por abstrair as regras de neg√≥cio
e controlar o acesso aos dados.

Isso deixar√° a camada model mais leve e objetiva. 

**Essa camada tamb√©m ser√° respons√°vel pelo acesso aos dados, validar√° se as informa√ß√µes recebidas 
do Controller s√£o suficientes para completar a requisi√ß√£o.**

- Centralizar o acesso aos dados e fun√ß√µes externas;
- Abstrair regras de neg√≥cios;
- N√£o ter nenhum "conhecimento" sobre a camada Model (EX: Query SQL);
- N√£o receber nada relacionada ao HTTP (Request ou Response).
<hr>

## Tratando exce√ß√µes

