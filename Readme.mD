# SPRING BOOT 3 - MICHELLI BRITO

## ANOTA√á√ïES SPRING

- @Component - Classe mais gen√©rica;
- @Service - Classe de servi√ßo, onde envolve regras de neg√≥cio;
- @Repository - Classe onde ter√° transa√ß√µes com base de dados;
- @Controller - Ter√° endpoints (URL).
- @RestController - Espec√≠fico para API Rest;
<hr>

## IN√çCIO
<hr>

### Core Container

√â dentro dele onde est√° a implementa√ß√£o de invers√£o de controle, utilizando a inje√ß√£o de depend√™ncia para gerenciar todos esse Beans. Mas...

### O que √© invers√£o de controle?  

√â um padr√£o de projeto, onde um objeto declara suas depend√™ncia mas n√£o as cria. O objeto deixa essa tarefa para o framework (Spring). O Spring far√° esse trabalho no Container IoC (Core Container), utilizando a inje√ß√£o de depend√™ncia.

### O que √© Inje√ß√£o de Depend√™ncia?

√â algo mais concreto. √â a implementa√ß√£o da inje√ß√£o de controle quando necess√°ria, √© feita pelo Spring Framework.

### O que s√£o Beans?

Nada mais √© do que um objeto que √© instanciado/montando/gerenciado por um Core Container do Spring, atrav√©s da Invers√£o de Controle e Inje√ß√£o de Depend√™ncia.
Exemplos.: @Component, @Service, @Repository, @Controller.

## Spring Boot

√â como se fosse uma somat√≥ria do Spring FrameWork + Servidor embutido (Tomcat ou Netty) - XML <bean> Configuration ou @Configuration

Antigamente precisava criar v√°rios arquivos XML pra definir algumas coisas, onde hoje tudo j√° vem configurado, automatizado e simplificado.
<hr>

## Overview do projeto

**PRODUTS API REStful - Products.**

### Model e Mapeamento da Entidade Product.
1. Criaremos um package model e uma classe ProductModel;
2. Passamos @Entity para ela se tornar uma entidade;
3. @Table(name = "TB_PRODUCTS");
4. Implementamos Serializable, passando private static final long serialVersionUID = 1L.

#### Inser√ß√£o de atributos
Algumas coisas aqui estar√£o diferentes do curso do N√©lio, uma vez que este curso √© um pouco mais atualizado.
Por exemplo:
1. o passar o GenerationType do Id, usaremos AUTO;
2. O Id n√£o ser√° integer e sim UUID;
   - UUID √© indicado para projetos que usam banco de dados, evita conflitos de termos ID semelhantes.
3. O value agora ser√° BigDecimal.
```java
@Entity
@Table(name = "TB_PRODUCTS")
public class ProductModel implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID idProduct;
    private String name;
    private BigDecimal value;
}
```
E agora, geramos nosso construtor e getters and setters. üòä
Rodando o c√≥digo Spring, dentro do pgAdmin 4 (postgres), a tabela ter√° sido inserida.


### Cria√ß√£o do Repository com JPA Repository
Contaremos com diversos m√©todos prontos sem precisar implementar cada um deles.
Seja para salvar recursos, obter uma lista de recursos um determinado recurso pelo ID, enfim... fazer tudo com JPA com facilidade!

1. Criaremos um novo pacote **repositories** com uma interface chamada ProductRepository;
2. Como sabemos, extendemos JpaRepository<**Entidade**, **Identificador**>;
3. Passamos a anota√ß√£o, pois precisamos mostrar pro spring que tal classe ser√° um bean gerenciado por ele;
   - Neste, caso: @Repository.
```java
@Repository
public interface ProductRepository extends JpaRepository<ProductModel, UUID> {}
```

### Cria√ß√£o do Controller

1. Criaremos um **ponto de inje√ß√£o**, visto que que Controller √© dependente de Repository.
   - Para isso, utilizaremos o @Autowired, importando o ProductRepository.
2. Implementaremos agora os m√©todos CRUD.

<hr>

#### POST
O POST receber√° o recurso, ir√° fazer uma valida√ß√£o inicial e salvar na base de dados.
Antes disso, para recebermos esses valores via JSON, precisaremos mapear esses campos.

Para isso, usaremos uma feature: **records**. Eles nos permitem iniciar esses objetos para transfer√™ncia de dados, como os DTOS por exemplo.
Criaremos portanto, um DTO, ele:
1. Ir√° receber dados desse recurso "Product";
2. Far√° a valida√ß√£o inicial;
3. Se tudo estiver OK, ele far√° a convers√£o para o model e salva este recurso na base de dados.
<hr>

### Mapeamento DTO de entrada com records
1. Criamos o pacote dtos;
2. Criamos um Record DTO, denominado ProductRecordDto;
3. Passaremos os par√¢metros do Product, menos ID pois n√£o precisamos nos preocupar.
```java
public record ProductRecordDto(String name, BigDecimal Value){}
```
Destacando-se que o Record j√° possui m√©todos prontos, como: getters/constructores/equals&hashcode etc.

Records al√©m disso, s√£o **IMUT√ÅVEIS**, por isso, n√£o possuem m√©todos **SETTERS**.

**Para validarmos, dentro do par√¢metro passaremos algumas anota√ß√µes, como:**
```java
public record ProductRecordDto(@NotBlank String name, @NotNull BigDecimal value) {}
```

<hr>

### M√âTODO POST

```java
@PostMapping("/products")
public ResponseEntity<ProductModel> saveProduct(@RequestBody @Valid ProductRecordDto productRecordDto) {
    var productModel = new ProductModel();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.CREATED).body(productRepository.save(productModel));
}
```
ResponseEntity - Retorno do m√©todo, neste caso do ProductModel, que na linha abaixo, ser√° criado.

O m√©todo saveProduct vai receber como par√¢metro (corpo da solicita√ß√£o Http) um ProductRecordDto que cont√© um name e um value.

@RequestBody - Ajuda a deixar a aplica√ß√£o no padr√£o REST, pois, sem ela, se mapeamos algum endere√ßo, o Spring entende que √© algo que est√° dentro da nossa aplica√ß√£o, como um arquivo, por exemplo. O @ResponseBody vai entender que esse √© um endere√ßo de uma p√°gina da web, obedecendo ao princ√≠pio do REST de comunica√ß√£o via protocolo HTTP.

@Valid - Para que esses dados entrem de fato em vigor

Dentro da fun√ß√£o iniciamos um ProductModel. O Dto serve somente para receber o que est√° vindo na requisi√ß√£o do corpo em formato JSON.

Por isso na linha abaixo, usamos o BeanUtils.copyProperties para fazer a convers√£o de JSON para Model.

Nessa ultima linha, construimos o retorno. O retorno do tipo ResponseEntity ser√° em duas partes:
1. Status - Se tudo ocorreu bem, precisamos enviar para o cliente que o recurso foi criado. Usamos portanto: HttpStatus.CREATED
2. J√° no .body (corpo) dessa reposta, poderemos enviar o que foi salvo. (Nome e Valor) que o cliente colocou + o ID que ser√° gerado.
3. E pra fazer esse save? Como pode ser observado, estamos importando o productRepository. Usaremos seu m√©todo .save dentro do body, passando nosso var productModel.
<hr>

#### M√âTODO GET
```java
@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

Como s√£o **TODOS** os produtos, ele ir√° nos retornar uma **List** do tipo ProductModel.

Diferente do c√≥digo post, ele ir√° nos retornar o HttpStatus.OK. E o m√©todo de repository √© o .findAll() que nos retornar√° uma lista.
<hr>

### M√âTODO GET (COM ID)

```java
@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    else {
        return ResponseEntity.status(HttpStatus.OK).body(productO.get());
    }
}
```

O @PathVariable nos ajuda a pegar o {id} passado no @Get.

O m√©todo nos retornar√° um Optional.

Instanciaremos um objeto ProductModel do tipo Optional, e entraremos no repository, usando o findById passando a ID do m√©todo como par√¢metro.
Depois, √© aquele if padr√£o. Se estiver vazio, lan√ßa a mensagem de not found. Se n√£o estiver vazio, pega o product e passa no corpo da resposta.

<hr>

### M√âTODO PUT (UPDATE)

Put √© parecido com o getOneProduct porque tamb√©m precisamos passar o ID como par√¢metro do que vamos atualizar.

```java
@PutMapping("/products/{id}")
public ResponseEntity<Object> updateProduct(@PathVariable(value = "id") UUID id,
                                                @RequestBody @Valid ProductRecordDto productRecordDto) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    var productModel = productO.get();
    BeanUtils.copyProperties(productRecordDto, productModel);
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.save(productModel));
}
```

Continua recebendo o PathVariable e UUID.

Mas dessa vez, receber√° tamb√©m o RequestBody e Valid, pois precisamos do name e value (ProductRecordDto) para realizarmos o update.

Criamos a vari√°vel productO que utilizando o repository, ir√° verificar se primeiro, o produto existe (buscando pela ID).

Se existir, fazemos o if para saber se est√° vazio.

Se n√£o estiver vazio, instanciaremos um ProductModel. Mas esse ProductModel, n√£o ser√° instanciado do zero igual na saveProduct. Iremos atribuir a essa vari√°vel o valor que ja recebeu da base dados "productO".

E da√≠ damos o retorno padr√£o dando o OK e salvando.
<hr>

### M√âTODO DEL (DELETE)



```java
@DeleteMapping("/products/{id}")
public ResponseEntity<Object> deleteProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productRepository.delete(productO.get());
    return ResponseEntity.status(HttpStatus.OK).body("Product deleted successfully.");
}
```
A partir de agora o c√≥digo ja est√° mais autoexplicativo.

Passamos os mesmos par√¢metros por√©m depois do if n√£o precisamos intanciar um ProductModel.

S√≥ passamos o delete do repository com o .get() para pegar toda a entidade.

Cabe destacar, que o repository possui outros deletes, tais como:
- deleteAll(), deleteById, etc...
<hr>

### Inserindo HATEOAS e Cria√ß√£o de hiperm√≠dias

Colocamos a depend√™ncia no maven.
```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

E extendemos na classe principal, tudo isso visando uma melhor **navegabilidade**.
```java
public class ProductModel extends RepresentationModel<ProductModel> implements Serializable {}
```

Agora, quando formos utilizar essa clase, internamente ele j√° vai ter alguns m√©todos (como add, por exemplo) para construimos alguns links para navegabilidade.
<hr>

### EXEMPLOS + ALTERA√á√ïES DOS M√âTODOS ACIMA.

#### NA CLASSE PRODUCTCONTROLLER <<<
Como √© poss√≠vel ver nos m√©todos acima, **fazemos no proprio retorno a busca ou save ou qualquer outro m√©todo do repository**, iremos mudar isso.

Import dos links e methodOn
```java
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;
```

Exemplo de altera√ß√£o:
```java
ANTES

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
    return ResponseEntity.status(HttpStatus.OK).body(productRepository.findAll());
}
```

```java
DEPOIS

@GetMapping("/products")
public ResponseEntity<List<ProductModel>> getAllProducts() {
   List<ProductModel> productsList = productRepository.findAll();
   if (!productsList.isEmpty()) {
      for (ProductModel product : productsList) {
         UUID id = product.getIdProduct();
         product.add(linkTo(methodOn(ProductController.class).getOneProduct(id)).withSelfRel());
      }
   }
   return ResponseEntity.status(HttpStatus.OK).body(productsList);
}
```

Em suma:
- Criamos uma Lista do tipo ProductModel e passamos o findAll dentro dela;
- Fazemos um if para saber se ela est√° vazia, se n√£o tiver:
  - Faremos um loop, criaremos uma vari√°vel ID e usaremos o product.add;
    - **O .add √© uma extens√£o do proprio RepresentationModel!**
  - Dentro do add, usaremos linkTo, methodOn e withSelfRel.

linkTo - Fala pra qual endpoint/m√©todo vamos redirecionar o cliente quando ele clicar neste link.

methodOn - Qual controller est√° esse m√©todo? E qual √© este m√©todo em s√≠ que vai receber esse redirecionamento?

Bom, se o cliente est√° numa lista de produtos, vamos redirecionar ele para um produto espec√≠fico, neste caso √© o **getOneProduct**.

1. Primeiro definimos qual Controller est√° esse m√©todo (ProductController.class);
2. E depois qual o nome desse m√©todo. Usaremos o m√©todo de baixo getOneProduct;
   3. Como esse m√©todo recebe um id, passamos o id que criamos em cima. (Id de cada um dos produtos iterado pelo for).

withSelfRel - Redireciona para cada um de seus produtos em s√≠.

![img_2.png](img_2.png)

```java
ALTERA√á√ÉO GET ONE PRODUCT

@GetMapping("/products/{id}")
public ResponseEntity<Object> getOneProduct(@PathVariable(value = "id") UUID id) {
    Optional<ProductModel> productO = productRepository.findById(id);
    if (productO.isEmpty()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found.");
    }
    productO.get().add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel("Products List"));
    return ResponseEntity.status(HttpStatus.OK).body(productO.get());
}
```

√önica diferen√ßa √© que n√£o referenciamos por getOne, faremos o m√©todo .getAllProducts().

![img_1.png](img_1.png)
